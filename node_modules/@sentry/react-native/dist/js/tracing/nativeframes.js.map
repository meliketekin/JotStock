{"version":3,"file":"nativeframes.js","sourceRoot":"","sources":["../../../src/js/tracing/nativeframes.ts"],"names":[],"mappings":"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","sourcesContent":["import { Span, Transaction } from '@sentry/tracing';\nimport { Event, EventProcessor } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport { NativeFramesResponse } from '../definitions';\nimport { NATIVE } from '../wrapper';\nimport { instrumentChildSpanFinish } from './utils';\n\ntype FramesMeasurements = Record<\n  'frames_total' | 'frames_slow' | 'frames_frozen',\n  { value: number }\n>;\n\n/**\n * A margin of error of 50ms is allowed for the async native bridge call.\n * Anything larger would reduce the accuracy of our frames measurements.\n */\nconst MARGIN_OF_ERROR_SECONDS = 0.05;\n\n/**\n * Instrumentation to add native slow/frozen frames measurements onto transactions.\n */\nexport class NativeFramesInstrumentation {\n  /** The native frames at the transaction finish time, keyed by traceId. */\n  private _finishFrames: Map<\n    string,\n    { timestamp: number; nativeFrames: NativeFramesResponse | null }\n  > = new Map();\n  /** The listeners for each native frames response, keyed by traceId */\n  private _framesListeners: Map<string, () => void> = new Map();\n  /** The native frames at the finish time of the most recent span. */\n  private _lastSpanFinishFrames?: {\n    timestamp: number;\n    nativeFrames: NativeFramesResponse;\n  };\n\n  public constructor(\n    addGlobalEventProcessor: (e: EventProcessor) => void,\n    doesExist: () => boolean\n  ) {\n    logger.log(\n      '[ReactNativeTracing] Native frames instrumentation initialized.'\n    );\n\n    addGlobalEventProcessor((event) => this._processEvent(event, doesExist));\n  }\n\n  /**\n   * To be called when a transaction is started.\n   * Logs the native frames at this start point and instruments child span finishes.\n   */\n  public onTransactionStart(transaction: Transaction): void {\n    void NATIVE.fetchNativeFrames().then((framesMetrics) => {\n      if (framesMetrics) {\n        transaction.setData('__startFrames', framesMetrics);\n      }\n    });\n\n    instrumentChildSpanFinish(transaction, (_: Span, endTimestamp?: number) => {\n      if (!endTimestamp) {\n        this._onSpanFinish();\n      }\n    });\n  }\n\n  /**\n   * To be called when a transaction is finished\n   */\n  public onTransactionFinish(transaction: Transaction): void {\n    void this._fetchFramesForTransaction(transaction);\n  }\n\n  /**\n   * Called on a span finish to fetch native frames to support transactions with trimEnd.\n   * Only to be called when a span does not have an end timestamp.\n   */\n  private _onSpanFinish(): void {\n    const timestamp = timestampInSeconds();\n\n    void NATIVE.fetchNativeFrames().then((nativeFrames) => {\n      if (nativeFrames) {\n        this._lastSpanFinishFrames = {\n          timestamp,\n          nativeFrames,\n        };\n      }\n    });\n  }\n\n  /**\n   * Returns the computed frames measurements and awaits for them if they are not ready yet.\n   */\n  private async _getFramesMeasurements(\n    traceId: string,\n    finalEndTimestamp: number,\n    startFrames: NativeFramesResponse\n  ): Promise<FramesMeasurements | null> {\n    if (this._finishFrames.has(traceId)) {\n      return this._prepareMeasurements(traceId, finalEndTimestamp, startFrames);\n    }\n\n    return new Promise((resolve) => {\n      const timeout = setTimeout(() => {\n        this._framesListeners.delete(traceId);\n\n        resolve(null);\n      }, 2000);\n\n      this._framesListeners.set(traceId, () => {\n        resolve(\n          this._prepareMeasurements(traceId, finalEndTimestamp, startFrames)\n        );\n\n        clearTimeout(timeout);\n        this._framesListeners.delete(traceId);\n      });\n    });\n  }\n\n  /**\n   * Returns the computed frames measurements given ready data\n   */\n  private _prepareMeasurements(\n    traceId: string,\n    finalEndTimestamp: number, // The actual transaction finish time.\n    startFrames: NativeFramesResponse\n  ): FramesMeasurements | null {\n    let finalFinishFrames: NativeFramesResponse | undefined;\n\n    const finish = this._finishFrames.get(traceId);\n    if (\n      finish &&\n      finish.nativeFrames &&\n      // Must be in the margin of error of the actual transaction finish time (finalEndTimestamp)\n      Math.abs(finish.timestamp - finalEndTimestamp) < MARGIN_OF_ERROR_SECONDS\n    ) {\n      finalFinishFrames = finish.nativeFrames;\n    } else if (\n      this._lastSpanFinishFrames &&\n      Math.abs(this._lastSpanFinishFrames.timestamp - finalEndTimestamp) <\n        MARGIN_OF_ERROR_SECONDS\n    ) {\n      // Fallback to the last span finish if it is within the margin of error of the actual finish timestamp.\n      // This should be the case for trimEnd.\n      finalFinishFrames = this._lastSpanFinishFrames.nativeFrames;\n    } else {\n      return null;\n    }\n\n    const measurements = {\n      frames_total: {\n        value: finalFinishFrames.totalFrames - startFrames.totalFrames,\n      },\n      frames_frozen: {\n        value: finalFinishFrames.frozenFrames - startFrames.frozenFrames,\n      },\n      frames_slow: {\n        value: finalFinishFrames.slowFrames - startFrames.slowFrames,\n      },\n    };\n\n    return measurements;\n  }\n\n  /**\n   * Fetch finish frames for a transaction at the current time. Calls any awaiting listeners.\n   */\n  private async _fetchFramesForTransaction(\n    transaction: Transaction\n  ): Promise<void> {\n    const startFrames = transaction.data.__startFrames as\n      | NativeFramesResponse\n      | undefined;\n\n    // This timestamp marks when the finish frames were retrieved. It should be pretty close to the transaction finish.\n    const timestamp = timestampInSeconds();\n    let finishFrames: NativeFramesResponse | null = null;\n    if (startFrames) {\n      finishFrames = await NATIVE.fetchNativeFrames();\n    }\n\n    this._finishFrames.set(transaction.traceId, {\n      nativeFrames: finishFrames,\n      timestamp,\n    });\n\n    this._framesListeners.get(transaction.traceId)?.();\n\n    setTimeout(() => this._cancelFinishFrames(transaction), 2000);\n  }\n\n  /**\n   * On a finish frames failure, we cancel the await.\n   */\n  private _cancelFinishFrames(transaction: Transaction): void {\n    if (this._finishFrames.has(transaction.traceId)) {\n      this._finishFrames.delete(transaction.traceId);\n\n      logger.log(\n        `[NativeFrames] Native frames timed out for ${transaction.op} transaction ${transaction.name}. Not adding native frames measurements.`\n      );\n    }\n  }\n\n  /**\n   * Adds frames measurements to an event. Called from a valid event processor.\n   * Awaits for finish frames if needed.\n   */\n  private async _processEvent(\n    event: Event,\n    doesExist: () => boolean\n  ): Promise<Event> {\n    if (!doesExist()) {\n      return event;\n    }\n\n    if (\n      event.type === 'transaction' &&\n      event.transaction &&\n      event.contexts &&\n      event.contexts.trace\n    ) {\n      const traceContext = event.contexts.trace as {\n        data?: { [key: string]: unknown };\n        trace_id: string;\n        name?: string;\n        op?: string;\n      };\n\n      const traceId = traceContext.trace_id;\n\n      if (traceId && traceContext.data?.__startFrames && event.timestamp) {\n        const measurements = await this._getFramesMeasurements(\n          traceId,\n          event.timestamp,\n          traceContext.data.__startFrames as NativeFramesResponse\n        );\n\n        if (!measurements) {\n          logger.log(\n            `[NativeFrames] Could not fetch native frames for ${traceContext.op} transaction ${event.transaction}. Not adding native frames measurements.`\n          );\n        } else {\n          logger.log(\n            `[Measurements] Adding measurements to ${\n              traceContext.op\n            } transaction ${event.transaction}: ${JSON.stringify(\n              measurements,\n              undefined,\n              2\n            )}`\n          );\n\n          event.measurements = {\n            ...(event.measurements ?? {}),\n            ...measurements,\n          };\n\n          this._finishFrames.delete(traceId);\n        }\n\n        delete traceContext.data.__startFrames;\n      }\n    }\n\n    return event;\n  }\n}\n"]}