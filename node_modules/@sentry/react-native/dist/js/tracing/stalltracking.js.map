{"version":3,"file":"stalltracking.js","sourceRoot":"","sources":["../../../src/js/tracing/stalltracking.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport { IdleTransaction, Span, Transaction } from '@sentry/tracing';\nimport { Measurements } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nexport interface StallMeasurements extends Measurements {\n  stall_count: { value: number };\n  stall_total_time: { value: number };\n  stall_longest_time: { value: number };\n}\n\nexport type StallTrackingOptions = {\n  /**\n   * How long in milliseconds an event loop iteration can be delayed for before being considered a \"stall.\"\n   * @default 100\n   */\n  minimumStallThreshold: number;\n};\n\n/** Margin of error of 20ms */\nconst MARGIN_OF_ERROR_SECONDS = 0.02;\n/** How long between each iteration in the event loop tracker timeout */\nconst LOOP_TIMEOUT_INTERVAL_MS = 50;\n/** Limit for how many transactions the stall tracker will track at a time to prevent leaks due to transactions not being finished */\nconst MAX_RUNNING_TRANSACTIONS = 10;\n\n/**\n * Stall measurement tracker inspired by the `JSEventLoopWatchdog` used internally in React Native:\n * https://github.com/facebook/react-native/blob/006f5afe120c290a37cf6ff896748fbc062bf7ed/Libraries/Interaction/JSEventLoopWatchdog.js\n *\n * However, we modified the interval implementation to instead have a fixed loop timeout interval of `LOOP_TIMEOUT_INTERVAL_MS`.\n * We then would consider that iteration a stall when the total time for that interval to run is greater than `LOOP_TIMEOUT_INTERVAL_MS + minimumStallThreshold`\n */\nexport class StallTrackingInstrumentation {\n  public isTracking: boolean = false;\n\n  private _minimumStallThreshold: number;\n\n  /** Total amount of time of all stalls that occurred during the current tracking session */\n  private _totalStallTime: number = 0;\n  /** Total number of stalls that occurred during the current tracking session */\n  private _stallCount: number = 0;\n\n  /** The last timestamp the iteration ran in milliseconds */\n  private _lastIntervalMs: number = 0;\n  private _timeout: ReturnType<typeof setTimeout> | null = null;\n\n  private _statsByTransaction: Map<\n    Transaction,\n    {\n      longestStallTime: number;\n      atStart: StallMeasurements;\n      atTimestamp: {\n        timestamp: number;\n        stats: StallMeasurements;\n      } | null;\n    }\n  > = new Map();\n\n  public constructor(\n    options: StallTrackingOptions = { minimumStallThreshold: 50 }\n  ) {\n    this._minimumStallThreshold = options.minimumStallThreshold;\n  }\n\n  /**\n   * @inheritDoc\n   * Not used for this integration. Instead call `registerTransactionStart` to start tracking.\n   */\n  public setupOnce(): void {\n    // Do nothing.\n  }\n\n  /**\n   * Register a transaction as started. Starts stall tracking if not already running.\n   * @returns A finish method that returns the stall measurements.\n   */\n  public onTransactionStart(transaction: Transaction): void {\n    if (this._statsByTransaction.has(transaction)) {\n      logger.error(\n        '[StallTracking] Tried to start stall tracking on a transaction already being tracked. Measurements might be lost.'\n      );\n\n      return;\n    }\n\n    this._startTracking();\n    this._statsByTransaction.set(transaction, {\n      longestStallTime: 0,\n      atTimestamp: null,\n      atStart: this._getCurrentStats(transaction),\n    });\n    this._flushLeakedTransactions();\n\n    if (transaction.spanRecorder) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const originalAdd = transaction.spanRecorder.add;\n\n      transaction.spanRecorder.add = (span: Span): void => {\n        originalAdd.apply(transaction.spanRecorder, [span]);\n\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        const originalSpanFinish = span.finish;\n\n        span.finish = (endTimestamp?: number) => {\n          // We let the span determine its own end timestamp as well in case anything gets changed upstream\n          originalSpanFinish.apply(span, [endTimestamp]);\n\n          // The span should set a timestamp, so this would be defined.\n          if (span.endTimestamp) {\n            this._markSpanFinish(transaction, span.endTimestamp);\n          }\n        };\n      };\n    }\n  }\n\n  /**\n   * Logs a transaction as finished.\n   * Stops stall tracking if no more transactions are running.\n   * @returns The stall measurements\n   */\n  public onTransactionFinish(\n    transaction: Transaction | IdleTransaction,\n    passedEndTimestamp?: number\n  ): void {\n    const transactionStats = this._statsByTransaction.get(transaction);\n\n    if (!transactionStats) {\n      // Transaction has been flushed out somehow, we return null.\n      logger.log(\n        '[StallTracking] Stall measurements were not added to transaction due to exceeding the max count.'\n      );\n\n      this._statsByTransaction.delete(transaction);\n      this._shouldStopTracking();\n\n      return;\n    }\n\n    const endTimestamp = passedEndTimestamp ?? transaction.endTimestamp;\n\n    const spans = transaction.spanRecorder\n      ? transaction.spanRecorder.spans\n      : [];\n    const finishedSpanCount = spans.reduce(\n      (count, s) => (s !== transaction && s.endTimestamp ? count + 1 : count),\n      0\n    );\n\n    const trimEnd = transaction.toContext().trimEnd;\n    const endWillBeTrimmed = trimEnd && finishedSpanCount > 0;\n\n    /*\n      This is not safe in the case that something changes upstream, but if we're planning to move this over to @sentry/javascript anyways,\n      we can have this temporarily for now.\n    */\n    const isIdleTransaction = 'activities' in transaction;\n\n    let statsOnFinish: StallMeasurements | undefined;\n    if (endTimestamp && isIdleTransaction) {\n      /*\n        There is different behavior regarding child spans in a normal transaction and an idle transaction. In normal transactions,\n        the child spans that aren't finished will be dumped, while in an idle transaction they're cancelled and finished.\n\n        Note: `endTimestamp` will always be defined if this is called on an idle transaction finish. This is because we only instrument\n        idle transactions inside `ReactNativeTracing`, which will pass an `endTimestamp`.\n      */\n\n      // There will be cancelled spans, which means that the end won't be trimmed\n      const spansWillBeCancelled = spans.some(\n        (s) =>\n          s !== transaction &&\n          s.startTimestamp < endTimestamp &&\n          !s.endTimestamp\n      );\n\n      if (endWillBeTrimmed && !spansWillBeCancelled) {\n        // the last span's timestamp will be used.\n\n        if (transactionStats.atTimestamp) {\n          statsOnFinish = transactionStats.atTimestamp.stats;\n        }\n      } else {\n        // this endTimestamp will be used.\n        statsOnFinish = this._getCurrentStats(transaction);\n      }\n    } else if (endWillBeTrimmed) {\n      // If `trimEnd` is used, and there is a span to trim to. If there isn't, then the transaction should use `endTimestamp` or generate one.\n      if (transactionStats.atTimestamp) {\n        statsOnFinish = transactionStats.atTimestamp.stats;\n      }\n    } else if (!endTimestamp) {\n      statsOnFinish = this._getCurrentStats(transaction);\n    }\n\n    this._statsByTransaction.delete(transaction);\n    this._shouldStopTracking();\n\n    if (!statsOnFinish) {\n      if (typeof endTimestamp !== 'undefined') {\n        logger.log(\n          '[StallTracking] Stall measurements not added due to `endTimestamp` being set.'\n        );\n      } else if (trimEnd) {\n        logger.log(\n          '[StallTracking] Stall measurements not added due to `trimEnd` being set but we could not determine the stall measurements at that time.'\n        );\n      }\n\n      return;\n    }\n\n    const measurements = {\n      stall_count: {\n        value:\n          statsOnFinish.stall_count.value -\n          transactionStats.atStart.stall_count.value,\n      },\n      stall_total_time: {\n        value:\n          statsOnFinish.stall_total_time.value -\n          transactionStats.atStart.stall_total_time.value,\n      },\n      stall_longest_time: statsOnFinish.stall_longest_time,\n    };\n\n    transaction.setMeasurements(measurements);\n  }\n\n  /**\n   * Logs the finish time of the span for use in `trimEnd: true` transactions.\n   */\n  private _markSpanFinish(\n    transaction: Transaction,\n    spanEndTimestamp: number\n  ): void {\n    const previousStats = this._statsByTransaction.get(transaction);\n    if (previousStats) {\n      if (\n        Math.abs(timestampInSeconds() - spanEndTimestamp) >\n        MARGIN_OF_ERROR_SECONDS\n      ) {\n        logger.log(\n          '[StallTracking] Span end not logged due to end timestamp being outside the margin of error from now.'\n        );\n\n        if (\n          previousStats.atTimestamp &&\n          previousStats.atTimestamp.timestamp < spanEndTimestamp\n        ) {\n          // We also need to delete the stat for the last span, as the transaction would be trimmed to this span not the last one.\n          this._statsByTransaction.set(transaction, {\n            ...previousStats,\n            atTimestamp: null,\n          });\n        }\n      } else {\n        this._statsByTransaction.set(transaction, {\n          ...previousStats,\n          atTimestamp: {\n            timestamp: spanEndTimestamp,\n            stats: this._getCurrentStats(transaction),\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the current stats for a transaction at a given time.\n   */\n  private _getCurrentStats(transaction: Transaction): StallMeasurements {\n    return {\n      stall_count: { value: this._stallCount },\n      stall_total_time: { value: this._totalStallTime },\n      stall_longest_time: {\n        value: this._statsByTransaction.get(transaction)?.longestStallTime ?? 0,\n      },\n    };\n  }\n\n  /**\n   * Start tracking stalls\n   */\n  private _startTracking(): void {\n    if (!this.isTracking) {\n      this.isTracking = true;\n      this._lastIntervalMs = Math.floor(timestampInSeconds() * 1000);\n\n      this._iteration();\n    }\n  }\n\n  /**\n   * Stops the stall tracking interval and calls reset().\n   */\n  private _stopTracking(): void {\n    this.isTracking = false;\n\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    this._reset();\n  }\n\n  /**\n   * Will stop tracking if there are no more transactions.\n   */\n  private _shouldStopTracking(): void {\n    if (this._statsByTransaction.size === 0) {\n      this._stopTracking();\n    }\n  }\n\n  /**\n   * Clears all the collected stats\n   */\n  private _reset(): void {\n    this._stallCount = 0;\n    this._totalStallTime = 0;\n    this._lastIntervalMs = 0;\n    this._statsByTransaction.clear();\n  }\n\n  /**\n   * Iteration of the stall tracking interval. Measures how long the timer strayed from its expected time of running, and how\n   * long the stall is for.\n   */\n  private _iteration(): void {\n    const now = timestampInSeconds() * 1000;\n    const totalTimeTaken = now - this._lastIntervalMs;\n\n    if (\n      totalTimeTaken >=\n      LOOP_TIMEOUT_INTERVAL_MS + this._minimumStallThreshold\n    ) {\n      const stallTime = totalTimeTaken - LOOP_TIMEOUT_INTERVAL_MS;\n      this._stallCount += 1;\n      this._totalStallTime += stallTime;\n\n      for (const [transaction, value] of this._statsByTransaction.entries()) {\n        const longestStallTime = Math.max(\n          value.longestStallTime ?? 0,\n          stallTime\n        );\n\n        this._statsByTransaction.set(transaction, {\n          ...value,\n          longestStallTime,\n        });\n      }\n    }\n\n    this._lastIntervalMs = now;\n\n    if (this.isTracking) {\n      this._timeout = setTimeout(\n        this._iteration.bind(this),\n        LOOP_TIMEOUT_INTERVAL_MS\n      );\n    }\n  }\n\n  /**\n   * Deletes leaked transactions (Earliest transactions when we have more than MAX_RUNNING_TRANSACTIONS transactions.)\n   */\n  private _flushLeakedTransactions(): void {\n    if (this._statsByTransaction.size > MAX_RUNNING_TRANSACTIONS) {\n      let counter = 0;\n      const len = this._statsByTransaction.size - MAX_RUNNING_TRANSACTIONS;\n      const transactions = this._statsByTransaction.keys();\n      for (const t of transactions) {\n        if (counter >= len) break;\n        counter += 1;\n        this._statsByTransaction.delete(t);\n      }\n    }\n  }\n}\n"]}