/*! @sentry/integrations 6.19.2 (f49c509) | https://github.com/getsentry/sentry-javascript */
(function (__window) {
var exports = {};

/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
const fallbackGlobalObject = {};
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
function getGlobalObject() {
    return (typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
            ? window // eslint-disable-line no-restricted-globals
            : typeof self !== 'undefined'
                ? self
                : fallbackGlobalObject);
}

// TODO: Implement different loggers for different environments
const global = getGlobalObject();
/** Prefix for logging strings */
const PREFIX = 'Sentry Logger ';
const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
/**
 * Temporarily unwrap `console.log` and friends in order to perform the given callback using the original methods.
 * Restores wrapping after the callback completes.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
    const global = getGlobalObject();
    if (!('console' in global)) {
        return callback();
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    const originalConsole = global.console;
    const wrappedLevels = {};
    // Restore all wrapped console methods
    CONSOLE_LEVELS.forEach(level => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (level in global.console && originalConsole[level].__sentry_original__) {
            wrappedLevels[level] = originalConsole[level];
            originalConsole[level] = originalConsole[level].__sentry_original__;
        }
    });
    // Perform callback manipulations
    const result = callback();
    // Revert restoration to wrapped state
    Object.keys(wrappedLevels).forEach(level => {
        originalConsole[level] = wrappedLevels[level];
    });
    return result;
}
/** JSDoc */
class Logger {
    /** JSDoc */
    constructor() {
        this._enabled = false;
    }
    /** JSDoc */
    disable() {
        this._enabled = false;
    }
    /** JSDoc */
    enable() {
        this._enabled = true;
    }
    /** JSDoc */
    log(...args) {
        if (!this._enabled) {
            return;
        }
        consoleSandbox(() => {
            global.console.log(`${PREFIX}[Log]:`, ...args);
        });
    }
    /** JSDoc */
    warn(...args) {
        if (!this._enabled) {
            return;
        }
        consoleSandbox(() => {
            global.console.warn(`${PREFIX}[Warn]:`, ...args);
        });
    }
    /** JSDoc */
    error(...args) {
        if (!this._enabled) {
            return;
        }
        consoleSandbox(() => {
            global.console.error(`${PREFIX}[Error]:`, ...args);
        });
    }
}
const sentryGlobal = global.__SENTRY__ || {};
const logger = sentryGlobal.logger || new Logger();
{
    // Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
    sentryGlobal.logger = logger;
    global.__SENTRY__ = sentryGlobal;
}

// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
const splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
/** JSDoc */
function splitPath(filename) {
    const parts = splitPathRe.exec(filename);
    return parts ? parts.slice(1) : [];
}
/** JSDoc */
function basename(path, ext) {
    let f = splitPath(path)[2];
    if (ext && f.substr(ext.length * -1) === ext) {
        f = f.substr(0, f.length - ext.length);
    }
    return f;
}

/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
const dateTimestampSource = {
    nowSeconds: () => Date.now() / 1000,
};
/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
    const { performance } = getGlobalObject();
    if (!performance || !performance.now) {
        return undefined;
    }
    // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
    //
    // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
    // performance.now() gives a date arbitrarily in the past.
    //
    // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
    // undefined.
    //
    // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
    // interact with data coming out of performance entries.
    //
    // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
    // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
    // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
    // observed skews that can be as long as days, weeks or months.
    //
    // See https://github.com/getsentry/sentry-javascript/issues/2590.
    //
    // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
    // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
    // transactions of long-lived web pages.
    const timeOrigin = Date.now() - performance.now();
    return {
        now: () => performance.now(),
        timeOrigin,
    };
}
/**
 * The Performance API implementation for the current platform, if available.
 */
const platformPerformance = getBrowserPerformance();
const timestampSource = platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,
    };
/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
dateTimestampSource.nowSeconds.bind(dateTimestampSource);
/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
const timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
// Re-exported with an old name for backwards-compatibility.
const timestampWithMs = timestampInSeconds;
/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
(() => {
    // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
    // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
    // data as reliable if they are within a reasonable threshold of the current time.
    const { performance } = getGlobalObject();
    if (!performance || !performance.now) {
        return undefined;
    }
    const threshold = 3600 * 1000;
    const performanceNow = performance.now();
    const dateNow = Date.now();
    // if timeOrigin isn't available set delta to threshold so it isn't used
    const timeOriginDelta = performance.timeOrigin
        ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
        : threshold;
    const timeOriginIsReliable = timeOriginDelta < threshold;
    // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
    // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
    // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
    // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
    // Date API.
    // eslint-disable-next-line deprecation/deprecation
    const navigationStart = performance.timing && performance.timing.navigationStart;
    const hasNavigationStart = typeof navigationStart === 'number';
    // if navigationStart isn't available set delta to threshold so it isn't used
    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    const navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
        // Use the more reliable time origin
        if (timeOriginDelta <= navigationStartDelta) {
            return performance.timeOrigin;
        }
        else {
            return navigationStart;
        }
    }
    return dateNow;
})();

/**
 * Used to extract Tracing integration from the current client,
 * without the need to import `Tracing` itself from the @sentry/apm package.
 * @deprecated as @sentry/tracing should be used over @sentry/apm.
 */
const TRACING_GETTER = {
    id: 'Tracing',
};
/**
 * Used to extract BrowserTracing integration from @sentry/tracing
 */
const BROWSER_TRACING_GETTER = {
    id: 'BrowserTracing',
};
const VUE_OP = 'ui.vue';
// Mappings from operation to corresponding lifecycle hook.
const HOOKS = {
    activate: ['activated', 'deactivated'],
    create: ['beforeCreate', 'created'],
    destroy: ['beforeDestroy', 'destroyed'],
    mount: ['beforeMount', 'mounted'],
    update: ['beforeUpdate', 'updated'],
};
const COMPONENT_NAME_REGEXP = /(?:^|[-_/])(\w)/g;
const ROOT_COMPONENT_NAME = 'root';
const ANONYMOUS_COMPONENT_NAME = 'anonymous component';
/** JSDoc */
class Vue {
    /**
     * @inheritDoc
     */
    constructor(options) {
        /**
         * @inheritDoc
         */
        this.name = Vue.id;
        /**
         * Cache holding already processed component names
         */
        this._componentsCache = {};
        /** Keep it as attribute function, to keep correct `this` binding inside the hooks callbacks  */
        // eslint-disable-next-line @typescript-eslint/typedef
        this._applyTracingHooks = (vm, getCurrentHub) => {
            // Don't attach twice, just in case
            if (vm.$options.$_sentryPerfHook) {
                return;
            }
            vm.$options.$_sentryPerfHook = true;
            const name = this._getComponentName(vm);
            const rootMount = name === ROOT_COMPONENT_NAME;
            const spans = {};
            // Render hook starts after once event is emitted,
            // but it ends before the second event of the same type.
            //
            // Because of this, we start measuring inside the first event,
            // but finish it before it triggers, to skip the event emitter timing itself.
            const rootHandler = (hook) => {
                const now = timestampWithMs();
                // On the first handler call (before), it'll be undefined, as `$once` will add it in the future.
                // However, on the second call (after), it'll be already in place.
                if (this._rootSpan) {
                    this._finishRootSpan(now, getCurrentHub);
                }
                else {
                    vm.$once(`hook:${hook}`, () => {
                        // Create an activity on the first event call. There'll be no second call, as rootSpan will be in place,
                        // thus new event handler won't be attached.
                        // We do this whole dance with `TRACING_GETTER` to prevent `@sentry/apm` from becoming a peerDependency.
                        // We also need to ask for the `.constructor`, as `pushActivity` and `popActivity` are static, not instance methods.
                        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                        // eslint-disable-next-line deprecation/deprecation
                        const tracingIntegration = getCurrentHub().getIntegration(TRACING_GETTER);
                        if (tracingIntegration) {
                            this._tracingActivity = tracingIntegration.constructor.pushActivity('Vue Application Render');
                            const transaction = tracingIntegration.constructor.getTransaction();
                            if (transaction) {
                                this._rootSpan = transaction.startChild({
                                    description: 'Application Render',
                                    op: VUE_OP,
                                });
                            }
                            // Use functionality from @sentry/tracing
                        }
                        else {
                            const activeTransaction = getActiveTransaction(getCurrentHub());
                            if (activeTransaction) {
                                this._rootSpan = activeTransaction.startChild({
                                    description: 'Application Render',
                                    op: VUE_OP,
                                });
                            }
                        }
                        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
                    });
                }
            };
            const childHandler = (hook, operation) => {
                // Skip components that we don't want to track to minimize the noise and give a more granular control to the user
                const shouldTrack = Array.isArray(this._options.tracingOptions.trackComponents)
                    ? this._options.tracingOptions.trackComponents.indexOf(name) > -1
                    : this._options.tracingOptions.trackComponents;
                if (!this._rootSpan || !shouldTrack) {
                    return;
                }
                const now = timestampWithMs();
                const span = spans[operation];
                // On the first handler call (before), it'll be undefined, as `$once` will add it in the future.
                // However, on the second call (after), it'll be already in place.
                if (span) {
                    span.finish();
                    this._finishRootSpan(now, getCurrentHub);
                }
                else {
                    vm.$once(`hook:${hook}`, () => {
                        if (this._rootSpan) {
                            spans[operation] = this._rootSpan.startChild({
                                description: `Vue <${name}>`,
                                op: `${VUE_OP}.${operation}`,
                            });
                        }
                    });
                }
            };
            // Each component has it's own scope, so all activities are only related to one of them
            this._options.tracingOptions.hooks.forEach(operation => {
                // Retrieve corresponding hooks from Vue lifecycle.
                // eg. mount => ['beforeMount', 'mounted']
                const internalHooks = HOOKS[operation];
                if (!internalHooks) {
                    logger.warn(`Unknown hook: ${operation}`);
                    return;
                }
                internalHooks.forEach(internalHook => {
                    const handler = rootMount
                        ? rootHandler.bind(this, internalHook)
                        : childHandler.bind(this, internalHook, operation);
                    const currentValue = vm.$options[internalHook];
                    if (Array.isArray(currentValue)) {
                        vm.$options[internalHook] = [handler, ...currentValue];
                    }
                    else if (typeof currentValue === 'function') {
                        vm.$options[internalHook] = [handler, currentValue];
                    }
                    else {
                        vm.$options[internalHook] = [handler];
                    }
                });
            });
        };
        logger.log('You are still using the Vue.js integration, consider moving to @sentry/vue');
        this._options = Object.assign(Object.assign({ 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            Vue: getGlobalObject().Vue, attachProps: true, logErrors: false, tracing: false }, options), { tracingOptions: Object.assign({ hooks: ['mount', 'update'], timeout: 2000, trackComponents: false }, options.tracingOptions) });
    }
    /**
     * @inheritDoc
     */
    setupOnce(_, getCurrentHub) {
        if (!this._options.Vue) {
            logger.error('Vue integration is missing a Vue instance');
            return;
        }
        this._attachErrorHandler(getCurrentHub);
        if (this._options.tracing) {
            this._startTracing(getCurrentHub);
        }
    }
    /**
     * Extract component name from the ViewModel
     */
    _getComponentName(vm) {
        // Such level of granularity is most likely not necessary, but better safe than sorry. — Kamil
        if (!vm) {
            return ANONYMOUS_COMPONENT_NAME;
        }
        if (vm.$root === vm) {
            return ROOT_COMPONENT_NAME;
        }
        if (!vm.$options) {
            return ANONYMOUS_COMPONENT_NAME;
        }
        if (vm.$options.name) {
            return vm.$options.name;
        }
        if (vm.$options._componentTag) {
            return vm.$options._componentTag;
        }
        // injected by vue-loader
        if (vm.$options.__file) {
            const unifiedFile = vm.$options.__file.replace(/^[a-zA-Z]:/, '').replace(/\\/g, '/');
            const filename = basename(unifiedFile, '.vue');
            return (this._componentsCache[filename] ||
                (this._componentsCache[filename] = filename.replace(COMPONENT_NAME_REGEXP, (_, c) => c ? c.toUpperCase() : '')));
        }
        return ANONYMOUS_COMPONENT_NAME;
    }
    /** Finish top-level span and activity with a debounce configured using `timeout` option */
    _finishRootSpan(timestamp, getCurrentHub) {
        if (this._rootSpanTimer) {
            clearTimeout(this._rootSpanTimer);
        }
        this._rootSpanTimer = setTimeout(() => {
            if (this._tracingActivity) {
                // We do this whole dance with `TRACING_GETTER` to prevent `@sentry/apm` from becoming a peerDependency.
                // We also need to ask for the `.constructor`, as `pushActivity` and `popActivity` are static, not instance methods.
                // eslint-disable-next-line deprecation/deprecation
                const tracingIntegration = getCurrentHub().getIntegration(TRACING_GETTER);
                if (tracingIntegration) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    tracingIntegration.constructor.popActivity(this._tracingActivity);
                }
            }
            // We should always finish the span, only should pop activity if using @sentry/apm
            if (this._rootSpan) {
                this._rootSpan.finish(timestamp);
            }
        }, this._options.tracingOptions.timeout);
    }
    /** Inject configured tracing hooks into Vue's component lifecycles */
    _startTracing(getCurrentHub) {
        const applyTracingHooks = this._applyTracingHooks;
        this._options.Vue.mixin({
            beforeCreate() {
                // eslint-disable-next-line deprecation/deprecation
                if (getCurrentHub().getIntegration(TRACING_GETTER) || getCurrentHub().getIntegration(BROWSER_TRACING_GETTER)) {
                    // `this` points to currently rendered component
                    applyTracingHooks(this, getCurrentHub);
                }
                else {
                    logger.error('Vue integration has tracing enabled, but Tracing integration is not configured');
                }
            },
        });
    }
    /** Inject Sentry's handler into owns Vue's error handler  */
    _attachErrorHandler(getCurrentHub) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        const currentErrorHandler = this._options.Vue.config.errorHandler;
        this._options.Vue.config.errorHandler = (error, vm, info) => {
            const metadata = {};
            if (vm) {
                try {
                    metadata.componentName = this._getComponentName(vm);
                    if (this._options.attachProps) {
                        metadata.propsData = vm.$options.propsData;
                    }
                }
                catch (_oO) {
                    logger.warn('Unable to extract metadata from Vue component.');
                }
            }
            if (info) {
                metadata.lifecycleHook = info;
            }
            if (getCurrentHub().getIntegration(Vue)) {
                // Capture exception in the next event loop, to make sure that all breadcrumbs are recorded in time.
                setTimeout(() => {
                    getCurrentHub().withScope(scope => {
                        scope.setContext('vue', metadata);
                        getCurrentHub().captureException(error);
                    });
                });
            }
            if (typeof currentErrorHandler === 'function') {
                currentErrorHandler.call(this._options.Vue, error, vm, info);
            }
            if (this._options.logErrors) {
                if (this._options.Vue.util) {
                    this._options.Vue.util.warn(`Error in ${info}: "${error && error.toString()}"`, vm);
                }
                // eslint-disable-next-line no-console
                console.error(error);
            }
        };
    }
}
/**
 * @inheritDoc
 */
Vue.id = 'Vue';
/** Grabs active transaction off scope */
function getActiveTransaction(hub) {
    if (hub && hub.getScope) {
        const scope = hub.getScope();
        if (scope) {
            return scope.getTransaction();
        }
    }
    return undefined;
}

exports.Vue = Vue;
exports.getActiveTransaction = getActiveTransaction;


  // Add this module's exports to the global `Sentry.Integrations`
  __window.Sentry = __window.Sentry || {};
  __window.Sentry.Integrations = __window.Sentry.Integrations || {};
  for (var key in exports) {
    if (Object.prototype.hasOwnProperty.call(exports, key)) {
      __window.Sentry.Integrations[key] = exports[key];
    }
  }
}(window));
//# sourceMappingURL=vue.es6.js.map
