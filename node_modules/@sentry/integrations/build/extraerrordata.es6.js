/*! @sentry/integrations 6.19.2 (f49c509) | https://github.com/getsentry/sentry-javascript */
(function (__window) {
var exports = {};

/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
const fallbackGlobalObject = {};
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
function getGlobalObject() {
    return (typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
            ? window // eslint-disable-line no-restricted-globals
            : typeof self !== 'undefined'
                ? self
                : fallbackGlobalObject);
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
// eslint-disable-next-line @typescript-eslint/unbound-method
const objectToString = Object.prototype.toString;
/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isError(wat) {
    switch (objectToString.call(wat)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
            return true;
        default:
            return isInstanceOf(wat, Error);
    }
}
function isBuiltin(wat, ty) {
    return objectToString.call(wat) === `[object ${ty}]`;
}
/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isString(wat) {
    return isBuiltin(wat, 'String');
}
/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPrimitive(wat) {
    return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
}
/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPlainObject(wat) {
    return isBuiltin(wat, 'Object');
}
/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isElement(wat) {
    return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
}
/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isSyntheticEvent(wat) {
    return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
}
/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem, keyAttrs) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        let currentElem = elem;
        const MAX_TRAVERSE_HEIGHT = 5;
        const MAX_OUTPUT_LEN = 80;
        const out = [];
        let height = 0;
        let len = 0;
        const separator = ' > ';
        const sepLength = separator.length;
        let nextStr;
        // eslint-disable-next-line no-plusplus
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem, keyAttrs);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el, keyAttrs) {
    const elem = el;
    const out = [];
    let className;
    let classes;
    let key;
    let attr;
    let i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
    const keyAttrPairs = keyAttrs && keyAttrs.length
        ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])
        : null;
    if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach(keyAttrPair => {
            out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
        });
    }
    else {
        if (elem.id) {
            out.push(`#${elem.id}`);
        }
        // eslint-disable-next-line prefer-const
        className = elem.className;
        if (className && isString(className)) {
            classes = className.split(/\s+/);
            for (i = 0; i < classes.length; i++) {
                out.push(`.${classes[i]}`);
            }
        }
    }
    const allowedAttrs = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < allowedAttrs.length; i++) {
        key = allowedAttrs[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push(`[${key}="${attr}"]`);
        }
    }
    return out.join('');
}

// TODO: Implement different loggers for different environments
const global$1 = getGlobalObject();
/** Prefix for logging strings */
const PREFIX = 'Sentry Logger ';
const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
/**
 * Temporarily unwrap `console.log` and friends in order to perform the given callback using the original methods.
 * Restores wrapping after the callback completes.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
    const global = getGlobalObject();
    if (!('console' in global)) {
        return callback();
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    const originalConsole = global.console;
    const wrappedLevels = {};
    // Restore all wrapped console methods
    CONSOLE_LEVELS.forEach(level => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (level in global.console && originalConsole[level].__sentry_original__) {
            wrappedLevels[level] = originalConsole[level];
            originalConsole[level] = originalConsole[level].__sentry_original__;
        }
    });
    // Perform callback manipulations
    const result = callback();
    // Revert restoration to wrapped state
    Object.keys(wrappedLevels).forEach(level => {
        originalConsole[level] = wrappedLevels[level];
    });
    return result;
}
/** JSDoc */
class Logger {
    /** JSDoc */
    constructor() {
        this._enabled = false;
    }
    /** JSDoc */
    disable() {
        this._enabled = false;
    }
    /** JSDoc */
    enable() {
        this._enabled = true;
    }
    /** JSDoc */
    log(...args) {
        if (!this._enabled) {
            return;
        }
        consoleSandbox(() => {
            global$1.console.log(`${PREFIX}[Log]:`, ...args);
        });
    }
    /** JSDoc */
    warn(...args) {
        if (!this._enabled) {
            return;
        }
        consoleSandbox(() => {
            global$1.console.warn(`${PREFIX}[Warn]:`, ...args);
        });
    }
    /** JSDoc */
    error(...args) {
        if (!this._enabled) {
            return;
        }
        consoleSandbox(() => {
            global$1.console.error(`${PREFIX}[Error]:`, ...args);
        });
    }
}
const sentryGlobal = global$1.__SENTRY__ || {};
const logger = sentryGlobal.logger || new Logger();
{
    // Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
    sentryGlobal.logger = logger;
    global$1.__SENTRY__ = sentryGlobal;
}

/**
 * Transforms any object into an object literal with all its attributes
 * attached to it.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 */
function getWalkSource(value) {
    if (isError(value)) {
        const error = value;
        const err = {
            message: error.message,
            name: error.name,
            stack: error.stack,
        };
        for (const i in error) {
            if (Object.prototype.hasOwnProperty.call(error, i)) {
                err[i] = error[i];
            }
        }
        return err;
    }
    if (isEvent(value)) {
        const event = value;
        const source = {};
        // Accessing event attributes can throw (see https://github.com/getsentry/sentry-javascript/issues/768 and
        // https://github.com/getsentry/sentry-javascript/issues/838), but accessing `type` hasn't been wrapped in a
        // try-catch in at least two years and no one's complained, so that's likely not an issue anymore
        source.type = event.type;
        try {
            source.target = isElement(event.target)
                ? htmlTreeAsString(event.target)
                : Object.prototype.toString.call(event.target);
        }
        catch (_oO) {
            source.target = '<unknown>';
        }
        try {
            source.currentTarget = isElement(event.currentTarget)
                ? htmlTreeAsString(event.currentTarget)
                : Object.prototype.toString.call(event.currentTarget);
        }
        catch (_oO) {
            source.currentTarget = '<unknown>';
        }
        if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {
            source.detail = event.detail;
        }
        for (const attr in event) {
            if (Object.prototype.hasOwnProperty.call(event, attr)) {
                source[attr] = event[attr];
            }
        }
        return source;
    }
    return value;
}

const defaultFunctionName = '<anonymous>';
/**
 * Safely extract function name from itself
 */
function getFunctionName(fn) {
    try {
        if (!fn || typeof fn !== 'function') {
            return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
    }
    catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        return defaultFunctionName;
    }
}

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Helper to decycle json objects
 */
function memoBuilder() {
    const hasWeakSet = typeof WeakSet === 'function';
    const inner = hasWeakSet ? new WeakSet() : [];
    function memoize(obj) {
        if (hasWeakSet) {
            if (inner.has(obj)) {
                return true;
            }
            inner.add(obj);
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < inner.length; i++) {
            const value = inner[i];
            if (value === obj) {
                return true;
            }
        }
        inner.push(obj);
        return false;
    }
    function unmemoize(obj) {
        if (hasWeakSet) {
            inner.delete(obj);
        }
        else {
            for (let i = 0; i < inner.length; i++) {
                if (inner[i] === obj) {
                    inner.splice(i, 1);
                    break;
                }
            }
        }
    }
    return [memoize, unmemoize];
}

/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output..
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
function normalize(input, depth = +Infinity, maxProperties = +Infinity) {
    try {
        // since we're at the outermost level, there is no key
        return walk('', input, depth, maxProperties);
    }
    catch (_oO) {
        return '**non-serializable**';
    }
}
/**
 * Walks an object to perform a normalization on it
 *
 * @param key of object that's walked in current iteration
 * @param value object to be walked
 * @param depth Optional number indicating how deep should walking be performed
 * @param maxProperties Optional maximum  number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
function walk(key, value, depth = +Infinity, maxProperties = +Infinity, memo = memoBuilder()) {
    const [memoize, unmemoize] = memo;
    // If we reach the maximum depth, serialize whatever is left
    if (depth === 0) {
        return serializeValue(value);
    }
    // If value implements `toJSON` method, call it and return early
    if (value !== null && value !== undefined && typeof value.toJSON === 'function') {
        return value.toJSON();
    }
    // `makeSerializable` provides a string representation of certain non-serializable values. For all others, it's a
    // pass-through. If what comes back is a primitive (either because it's been stringified or because it was primitive
    // all along), we're done.
    const serializable = makeSerializable(value, key);
    if (isPrimitive(serializable)) {
        return serializable;
    }
    // Create source that we will use for the next iteration. It will either be an objectified error object (`Error` type
    // with extracted key:value pairs) or the input itself.
    const source = getWalkSource(value);
    // Create an accumulator that will act as a parent for all future itterations of that branch
    const acc = Array.isArray(value) ? [] : {};
    // If we already walked that branch, bail out, as it's circular reference
    if (memoize(value)) {
        return '[Circular ~]';
    }
    let propertyCount = 0;
    // Walk all keys of the source
    for (const innerKey in source) {
        // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
        if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
            continue;
        }
        if (propertyCount >= maxProperties) {
            acc[innerKey] = '[MaxProperties ~]';
            break;
        }
        propertyCount += 1;
        // Recursively walk through all the child nodes
        const innerValue = source[innerKey];
        acc[innerKey] = walk(innerKey, innerValue, depth - 1, maxProperties, memo);
    }
    // Once walked through all the branches, remove the parent from memo storage
    unmemoize(value);
    // Return accumulated values
    return acc;
}
/**
 * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,
 * booleans, null, and undefined.
 *
 * @param value The value to stringify
 * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or
 *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,
 *  unchanged.
 */
function serializeValue(value) {
    // Node.js REPL notation
    if (typeof value === 'string') {
        return value;
    }
    const type = Object.prototype.toString.call(value);
    if (type === '[object Object]') {
        return '[Object]';
    }
    if (type === '[object Array]') {
        return '[Array]';
    }
    // `makeSerializable` provides a string representation of certain non-serializable values. For all others, it's a
    // pass-through.
    const serializable = makeSerializable(value);
    return isPrimitive(serializable) ? serializable : type;
}
/**
 * makeSerializable()
 *
 * Takes unserializable input and make it serializer-friendly.
 *
 * Handles globals, functions, `undefined`, `NaN`, and other non-serializable values.
 */
function makeSerializable(value, key) {
    if (key === 'domain' && value && typeof value === 'object' && value._events) {
        return '[Domain]';
    }
    if (key === 'domainEmitter') {
        return '[DomainEmitter]';
    }
    if (typeof global !== 'undefined' && value === global) {
        return '[Global]';
    }
    // It's safe to use `window` and `document` here in this manner, as we are asserting using `typeof` first
    // which won't throw if they are not present.
    // eslint-disable-next-line no-restricted-globals
    if (typeof window !== 'undefined' && value === window) {
        return '[Window]';
    }
    // eslint-disable-next-line no-restricted-globals
    if (typeof document !== 'undefined' && value === document) {
        return '[Document]';
    }
    // React's SyntheticEvent thingy
    if (isSyntheticEvent(value)) {
        return '[SyntheticEvent]';
    }
    if (typeof value === 'number' && value !== value) {
        return '[NaN]';
    }
    if (value === void 0) {
        return '[undefined]';
    }
    if (typeof value === 'function') {
        return `[Function: ${getFunctionName(value)}]`;
    }
    // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable
    if (typeof value === 'symbol') {
        return `[${String(value)}]`;
    }
    if (typeof value === 'bigint') {
        return `[BigInt: ${String(value)}]`;
    }
    return value;
}

/** Patch toString calls to return proper name for wrapped functions */
class ExtraErrorData {
    /**
     * @inheritDoc
     */
    constructor(options) {
        /**
         * @inheritDoc
         */
        this.name = ExtraErrorData.id;
        this._options = Object.assign({ depth: 3 }, options);
    }
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor((event, hint) => {
            const self = getCurrentHub().getIntegration(ExtraErrorData);
            if (!self) {
                return event;
            }
            return self.enhanceEventWithErrorData(event, hint);
        });
    }
    /**
     * Attaches extracted information from the Error object to extra field in the Event
     */
    enhanceEventWithErrorData(event, hint) {
        if (!hint || !hint.originalException || !isError(hint.originalException)) {
            return event;
        }
        const name = hint.originalException.name || hint.originalException.constructor.name;
        const errorData = this._extractErrorData(hint.originalException);
        if (errorData) {
            let contexts = Object.assign({}, event.contexts);
            const normalizedErrorData = normalize(errorData, this._options.depth);
            if (isPlainObject(normalizedErrorData)) {
                contexts = Object.assign(Object.assign({}, event.contexts), { [name]: Object.assign({}, normalizedErrorData) });
            }
            return Object.assign(Object.assign({}, event), { contexts });
        }
        return event;
    }
    /**
     * Extract extra information from the Error object
     */
    _extractErrorData(error) {
        // We are trying to enhance already existing event, so no harm done if it won't succeed
        try {
            const nativeKeys = [
                'name',
                'message',
                'stack',
                'line',
                'column',
                'fileName',
                'lineNumber',
                'columnNumber',
                'toJSON',
            ];
            const extraErrorInfo = {};
            // We want only enumerable properties, thus `getOwnPropertyNames` is redundant here, as we filter keys anyway.
            for (const key of Object.keys(error)) {
                if (nativeKeys.indexOf(key) !== -1) {
                    continue;
                }
                const value = error[key];
                extraErrorInfo[key] = isError(value) ? value.toString() : value;
            }
            // Check if someone attached `toJSON` method to grab even more properties (eg. axios is doing that)
            if (typeof error.toJSON === 'function') {
                const serializedError = error.toJSON();
                for (const key of Object.keys(serializedError)) {
                    const value = serializedError[key];
                    extraErrorInfo[key] = isError(value) ? value.toString() : value;
                }
            }
            return extraErrorInfo;
        }
        catch (oO) {
            logger.error('Unable to extract extra data from the Error object:', oO);
        }
        return null;
    }
}
/**
 * @inheritDoc
 */
ExtraErrorData.id = 'ExtraErrorData';

exports.ExtraErrorData = ExtraErrorData;


  // Add this module's exports to the global `Sentry.Integrations`
  __window.Sentry = __window.Sentry || {};
  __window.Sentry.Integrations = __window.Sentry.Integrations || {};
  for (var key in exports) {
    if (Object.prototype.hasOwnProperty.call(exports, key)) {
      __window.Sentry.Integrations[key] = exports[key];
    }
  }
}(window));
//# sourceMappingURL=extraerrordata.es6.js.map
